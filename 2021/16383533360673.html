

<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    动态化方案VirtualView的实战与思考 - mweb
    
    </title>
    
    
    
    <link href="atom.xml" rel="alternate" title="mweb" type="application/atom+xml">
    <link rel="stylesheet" href="asset/style.css">
    
</head>
  <body>




        <div id="wrapper">
            <header class="site-header">
                <div class="container">
                    <div class="site-title-wrapper">
                          <a class="button-square" href="index.html">
<svg class="svg-inline--fa fa-home fa-w-18" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="home" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512" data-fa-i2svg=""><path fill="currentColor" d="M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z"></path></svg>
                            </a>
                        
                         
                        
                        
                        
                        
                      
                      <a class="button-square" href="atom.xml" target="_blank" title="RSS">
                              <svg class="svg-inline--fa fa-rss fa-w-14" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                      </a>

              
                       
                         
                        
                    </div>

                    <ul class="site-nav">
                        
                    </ul>
                </div>
            </header>

            <div id="container">

 
<div class="container">
  <article class="post-container">
    <header class="post-header">
        <h1 class="post-title">动态化方案VirtualView的实战与思考</h1>
        <p class="post-date">
                <span>Posted <time datetime="2021/12/01" itemprop="datePublished">2021/12/01</time></span>
            </p>
    </header>

    <div class="post-content clearfix">
<h2><a id="%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>理论部分</h2>
<h4><a id="%E4%BA%86%E8%A7%A3%E5%8F%91%E5%B1%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>了解发展</h4>
<p>VirtualView 是 Tangram 升级过程中引入的新的组件开发技术，是为了解决业务组件的动态更新而生的，它提供了一系列基础 UI 组件和布局组件能力。主要功能包括：</p>
<ul>
<li>一份模板，两端支持。</li>
<li>提供基础的原子控件与容器控件，支持加入自定义组件。</li>
<li>支持一种虚拟化实现控件的协议，在模板里混合使用虚拟控件和实体控件。</li>
<li>支持在模板里编写数据绑定的表达式。</li>
<li>支持在模板里写事件触发的逻辑表达式。</li>
<li>提供配套的开发工具，辅助模板开发工具。</li>
</ul>
<p>动态方案也是从vlayout--&gt;Tangram--&gt;VirtualView的蜕变。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>成果</th>
<th>不足</th>
</tr>
</thead>
<tbody>
<tr>
<td>vlayout</td>
<td>混合使用各种布局</td>
<td>只能通过Java使用，只能写到客户端上</td>
</tr>
<tr>
<td>Tangram</td>
<td>通过json来动态配置布局</td>
<td>依然需要用Java去写</td>
</tr>
<tr>
<td>VirtualView</td>
<td>通过XML来动态配置组件</td>
<td>原子控件需要发版解决</td>
</tr>
</tbody>
</table>
<p>Tangram的动态框架从载体来区分是从以下步骤演变的：</p>
<ul>
<li>
<p>WebView+HTML<br />
HTML页面通过Hybrid接口还能与Native进行交互；动态性不错，但当时WebView有性能瓶颈。</p>
</li>
<li>
<p>动态Native<br />
内置基础组件（文本，图片，Button等）和函数（数学运算，字符串，网络等），以JSON为模板描述页面；兼具HTML方案的动态性和Native方案的高性能，但JSON定义的模板不具备通用性，效率问题推广不易。</p>
</li>
<li>
<p>VirtualView<br />
内置实现了一系列基础控件，可以让使用方直接上手尝试；搭建业务组件的方式采用 XML 模板来编写，这使得业务组件动态更新成为了可能。而且在样式动态化、数据动态化的场景下都能非常方便地实现业务需求。</p>
</li>
</ul>
<h4><a id="%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动态化方案对比</h4>
<p>其他方案对比优劣：</p>
<table>
<thead>
<tr>
<th style="text-align: center"></th>
<th style="text-align: center">Web容器</th>
<th style="text-align: center">RN</th>
<th style="text-align: center">Flexbox</th>
<th style="text-align: center">Picasso</th>
<th style="text-align: center">Patch</th>
<th style="text-align: center">VirtualView</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center">维护成本</td>
<td style="text-align: center">适中</td>
<td style="text-align: center">适中</td>
<td style="text-align: center">较好</td>
<td style="text-align: center">较好</td>
<td style="text-align: center">较好</td>
<td style="text-align: center">好</td>
</tr>
<tr>
<td style="text-align: center">兼容性</td>
<td style="text-align: center">较好</td>
<td style="text-align: center">较好</td>
<td style="text-align: center">适中</td>
<td style="text-align: center">适中</td>
<td style="text-align: center">适中</td>
<td style="text-align: center">较好</td>
</tr>
<tr>
<td style="text-align: center">逻辑支持</td>
<td style="text-align: center">较好</td>
<td style="text-align: center">较好</td>
<td style="text-align: center">差</td>
<td style="text-align: center">适中</td>
<td style="text-align: center">较好</td>
<td style="text-align: center">差</td>
</tr>
<tr>
<td style="text-align: center">页面级支持</td>
<td style="text-align: center">好</td>
<td style="text-align: center">好</td>
<td style="text-align: center">差</td>
<td style="text-align: center">适中</td>
<td style="text-align: center">适中</td>
<td style="text-align: center">适中</td>
</tr>
<tr>
<td style="text-align: center">跨平台</td>
<td style="text-align: center">好</td>
<td style="text-align: center">好</td>
<td style="text-align: center">好</td>
<td style="text-align: center">好</td>
<td style="text-align: center">差</td>
<td style="text-align: center">好</td>
</tr>
<tr>
<td style="text-align: center">布局能力</td>
<td style="text-align: center">好</td>
<td style="text-align: center">好</td>
<td style="text-align: center">好</td>
<td style="text-align: center">适中</td>
<td style="text-align: center">适中</td>
<td style="text-align: center">好</td>
</tr>
<tr>
<td style="text-align: center">成熟度</td>
<td style="text-align: center">好</td>
<td style="text-align: center">好</td>
<td style="text-align: center">适中</td>
<td style="text-align: center">差</td>
<td style="text-align: center">好</td>
<td style="text-align: center">好</td>
</tr>
<tr>
<td style="text-align: center">包大小</td>
<td style="text-align: center">好</td>
<td style="text-align: center">适中</td>
<td style="text-align: center">好</td>
<td style="text-align: center">好</td>
<td style="text-align: center">好</td>
<td style="text-align: center">好</td>
</tr>
<tr>
<td style="text-align: center">App Store政策风险</td>
<td style="text-align: center">好</td>
<td style="text-align: center">好</td>
<td style="text-align: center">好</td>
<td style="text-align: center">好</td>
<td style="text-align: center">差</td>
<td style="text-align: center">好</td>
</tr>
<tr>
<td style="text-align: center">适用场景</td>
<td style="text-align: center">对性能要求不高，交互简单的页面</td>
<td style="text-align: center">Web容器方案的增强版</td>
<td style="text-align: center">无需动态逻辑支持的纯内嵌View展示场景</td>
<td style="text-align: center">需要简单动态逻辑支持的内嵌View展示场景</td>
<td style="text-align: center">热修复</td>
<td style="text-align: center">无需动态逻辑支持的纯内嵌View展示场景</td>
</tr>
<tr>
<td style="text-align: center">静态性能</td>
<td style="text-align: center">差</td>
<td style="text-align: center">适中</td>
<td style="text-align: center">较好</td>
<td style="text-align: center">适中</td>
<td style="text-align: center">适中</td>
<td style="text-align: center">好</td>
</tr>
<tr>
<td style="text-align: center">滚动性能</td>
<td style="text-align: center">差</td>
<td style="text-align: center">适中</td>
<td style="text-align: center">适中</td>
<td style="text-align: center">适中</td>
<td style="text-align: center">适中</td>
<td style="text-align: center">好</td>
</tr>
<tr>
<td style="text-align: center">区块级支持</td>
<td style="text-align: center">差</td>
<td style="text-align: center">差</td>
<td style="text-align: center">好</td>
<td style="text-align: center">好</td>
<td style="text-align: center">适中</td>
<td style="text-align: center">好</td>
</tr>
</tbody>
</table>
<h4><a id="%E6%96%B9%E6%A1%88%E5%85%B3%E7%B3%BB%E8%A7%92%E8%89%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方案关系角色</h4>
<ul>
<li>模板SDK<br />
　　提供NA端加载相关API，下载管理远程模板可执行文件，解析并创建成NA组件的工作。</li>
<li>模板平台<br />
　　管理模板文件的存储、版本、环境、渠道等一些列复杂的工作。</li>
<li>NA端<br />
　　加载动态视图，GUI的管理逻辑、本地写入以及其他渲染优化工作。</li>
<li>模板文件<br />
　　由开发端按照规则进行调试开发完成，原始的xml样式文件。<br />
　　</li>
</ul>
<h4><a id="%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>相关资源</h4>
<p>注意事项：</p>
<ul>
<li>运行预览工具之前，需要先执行模板工程根目录下的run.sh脚本启动服务；</li>
<li>然后就可以在templates下新增自己的目标模板（xml、json）即可；</li>
<li>模板命名建议：渠道_模块_描述（示例：decorate_shop_product）</li>
</ul>
<p>开发过程中我们必须要知道具体的核心文件的作用，知其然也要知其所以然。<br />
工具核心文件释义说明如下：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>build.gradle</td>
<td>编译配置</td>
</tr>
<tr>
<td>buildTemplate.sh</td>
<td>编译执行脚本</td>
</tr>
<tr>
<td>compiler-tools</td>
<td>编译工具java工程</td>
</tr>
<tr>
<td>compiler.jar</td>
<td>xml 的编译逻辑执行文件</td>
</tr>
<tr>
<td>config.gradle</td>
<td>模板工程配置</td>
</tr>
<tr>
<td>config.properties</td>
<td>组件配置 (ID、xml 属性的 value 类型)</td>
</tr>
<tr>
<td>run.sh</td>
<td>模板服务启动脚本</td>
</tr>
<tr>
<td>fswatch-1.11.2</td>
<td>跨平台的文件更改监视器</td>
</tr>
<tr>
<td>templates</td>
<td>xml模板文件集合</td>
</tr>
</tbody>
</table>
<p>编译产物如图所示：<br />
<figure><img src="media/16346252672275/1-3.png" alt="1" /><figcaption>1<figcaption></figure></p>
<table>
<thead>
<tr>
<th>文件</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>data.json</td>
<td>汇总数据（可执行文件、模板数据、模板名称）</td>
</tr>
<tr>
<td>.png</td>
<td>汇总数据二维码</td>
</tr>
<tr>
<td>.json</td>
<td>模板绑定数据</td>
</tr>
<tr>
<td>.out</td>
<td>模板可执行文件</td>
</tr>
<tr>
<td>.xml</td>
<td>模板样式文件</td>
</tr>
</tbody>
</table>
<h4><a id="%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>工作流程</h4>
<p>平台 SDK 业务 关系图<br />
具体接口关系图如下：<br />
<figure><img src="media/16346252672275/4-3.png" alt="" /></figure></p>
<p>具体业务流程图如下：<br />
<figure><img src="media/16346252672275/16372067553981.jpg" alt="" /></figure></p>
<h4><a id="%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方案原理</h4>
<p>掌握工作流程以后，我们接下来剖析一下它的原理，加深我们的理解和掌握的深度。</p>
<ul>
<li>通过 XML 来搭建业务组件，并将 XML 模板编译成二进制数据</li>
<li>主体框架解析二进制数据并渲染出视图</li>
<li>XML 模板数据动态下发</li>
<li>客户端上的业务组件视图也就能动态更新了</li>
</ul>
<h4><a id="%E7%BC%96%E8%AF%91%E9%80%BB%E8%BE%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编译逻辑</h4>
<p>模板文件编译、可执行文件逆向解析如图所示：<br />
<figure><img src="media/16346252672275/3-2.jpg" alt="模板文件编译流程　　　　　　　　　　　　　　　　　　　可执行文件的解析流程" /><figcaption>模板文件编译流程　　　　　　　　　　　　　　　　　　　可执行文件的解析流程<figcaption></figure><br />
编译过程的数据源是开发好的xml样式文件，编译器先按照固定的格式依次写入组件区、字符串区、表达式区等占位空间，然后解析并递归获取xml节点，获取对应数据循环写入可执行文件，待所有节点循环结束，文件编译完成。<br />
可执行文件的解析可理解为编译工作的逆操作。</p>
<p>组件构建流程如图所示：<br />
<figure><img src="media/16346252672275/16375776768766.jpg" alt="" /></figure><br />
我们通过模板名找到对应的可执行文件，读取一个字节，判断是否是节点开始标志，是则读取节点相关数据，如果否我们继续判断是否是结束节点、如果结束继续找寻是否有节点，再判断是否为容器类就添加到父容器，继续往下递归读取，直到栈中没有了节点，则完成了整个组件的创建。</p>
<h2><a id="%E5%AE%9E%E8%B7%B5%E9%83%A8%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实践部分</h2>
<h4><a id="%E4%B8%9A%E5%8A%A1%E5%B1%95%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>业务展示</h4>
<p>动态化实践在贝壳家居业务的使用如下图所展示：<br />
<figure><img src="media/16346252672275/4.jpg" alt="" /></figure><br />
根据当前的后台数据，可以看到第一个是banner，第二个是服务承偌，第三个是好物推荐模块，第四个就是feed流商品模块。</p>
<p>目前家居侧已经在好物推荐和feed流商品中使用，由于动态方案的一端开发，多端可配置使用，动态、提效等优势，所以倾向动态内容占比大一些，目前已经上线并运行良好。</p>
<h4><a id="%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88%E5%8A%A0%E8%BD%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动态化方案加载</h4>
<p>模板下载更新代码示例</p>
<pre><code class="language-plain_text">/// 下载全部可用模板
+ (void)downloadAllTemplete:(void (^)(LJAllTempleteModel *meteInfo))metaInfoHandler
         allTempleteHandler:(void (^)(void))success
                    failure:(void (^)(NSError *error))failure {
    NSString *url = [NSString stringWithFormat:@&quot;%@/model/list&quot;, [LJTempleteLoader sharedManager].urlPath];
    [LJTempleteAPI requestAllTempleteWithURL:url params:nil success:^(NSDictionary *ret) {
        if (ret.count &gt; 0) {
            // 1.删除过期（模版version低版本）模版
            LJAllTempleteModel *allTempleteModel = [LJAllTempleteModel yy_modelWithJSON:ret];
            for (LJTempleteModel *templeteModel in allTempleteModel.list) {
                NSString *sign = templeteModel.signatureString;
            }
            [self cleanExpiredTempleteByNewMeta:allTempleteModel];
            // 2.存储新模版所有信息
            NSDictionary *fullRet = [allTempleteModel yy_modelToJSONObject];
    ...
}
</code></pre>
<p>模板加载代码示例</p>
<pre><code class="language-plain_text">@weakify(self)
[[LJTempleteLoader sharedManager] loadWithTempleteName:model.templateName
                                               success:^{
    @strongify(self)
    [self loadeDynamicView];
    [self.contentView addSubview:self.dynamicView];
} failure:^(NSError *error) {
    //上报自定义错误
    [JGCustomErrorUtil errorDomain:nil
                              type:JGCustomErrorNameDynamicUI
                           subtype:NSStringFromClass([self class])
                        byPassType:nil
                       byPassValue:nil
                         component:nil
                              code:0
                            extras:nil];
}];
</code></pre>
<p>渲染展示代码示例</p>
<pre><code class="language-plain_text">- (void)loadeDynamicView
{
    NSDictionary *jsonData = [self.viewModel yy_modelToJSONObject];
    NSMutableDictionary *muDic = [self.class remakeJsonData:jsonData];
    [self.dynamicView updateData:muDic];
    CGSize dynamicSize = [self.dynamicView estimatedSize:CGSizeMake((Screen_Width - 40 - JGFeedItemSpace) / JGFeedColumnCount, CGFLOAT_MAX)];
    self.dynamicView.frame = CGRectMake(0, 0, dynamicSize.width, dynamicSize.height);
    [self.dynamicView updateLayout];
}
</code></pre>
<h4><a id="%E5%9C%BA%E6%99%AF%E5%8C%BA%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>场景区分</h4>
<p>【单个视图】<br />
对于单视图，表现良好，直接进行加载、渲染，加上保底方案：本地模板或者NAcode，基本上可以满足绝大数业务需求。</p>
<p>【列表视图】<br />
针对列表视图，使用动态模板的话，需要注意的问题就多了：整体动态汇总高度计算、预加载数据量、是否有频繁刷新需求以及耗时监控。<br />
这里我们强调一下耗时问题，对于移动端的列表体验是移动开发的重中之重，毕竟加入单个耗时较少的话，但N量级的话我们是不能忽视的。对于iOS来说，如果阻塞执行耗时超过16.67毫秒，用户肉眼就是可以感受到卡顿的。</p>
<h2><a id="%E6%80%A7%E8%83%BD%E9%83%A8%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>性能部分</h2>
<h4><a id="%E5%8A%A0%E8%BD%BD%E8%80%97%E6%97%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>加载耗时</h4>
<p>针对性能问题，我们也不用害怕，我们进行逐一分析和解决即可。<br />
预加载，开发过程中想要节省动态视图的整体耗时的，这里我们可以前置创建，这样我们使用时直接获取已经生成好的视图即可，节省耗时。</p>
<p>渲染时，官方代码中重设frame也在其中，这本身没什么大的问题，其实我们可以首次进行设置，后续的渲染如果是不会影响整体高度的刷新，这一行我们也可以前置。</p>
<p>高度汇总，由<code>estimatedSize</code>方法是要走<code>updateData</code>方法之后才能得到，这块我们可以进行预加载操作，预加载数量契合重用机制，为满屏承载的最大个数即可。计算每个高度时，只用其中一个当做承载容器，最后汇总即可。</p>
<p>整体的核心思想也是内存和CPU的权衡，对于当下主流手机的内存大小是完全没有问题的。</p>
<h4><a id="%E5%88%B7%E6%96%B0%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>刷新问题</h4>
<p>这里引用一下官方原版关于刷新相关内容：</p>
<pre><code class="language-plain_text">{
    [self.viewContainer updateData:@{
        @&quot;type&quot; : @&quot;icon-type&quot;,
        @&quot;imgUrl&quot; : @&quot;https://test.com/test.png&quot;
    }];
    CGSize size = CGSizeMake(MAX_WIDTH, MAX_HEIGHT);
    size = [self.viewContainer estimatedSize:size];
    self.viewContainer.frame = CGRectMake(0, 0, size.width, size.height);
    [self.viewContainer updateLayout];
}

计算尺寸的话，更新数据和更新布局要分步处理：
1、首先调用 updateData 进行数据的更新
2、准备好最大约束尺寸，用 estimatedSize 方法计算预估的组件大小
3、设定好组件的正确尺寸，最后用 updateLayout 更新组件内部元素布局
</code></pre>
<br>
可见VirtualView不支持更细粒度的单个控件进行刷新，也就是说模板不支持视图中某一个元素单独刷新，只能视图全刷新。
由此细心的小伙伴应该已经知道瓶颈边界所在了，即对于需要频繁刷新的业务需求支持就是不太友好的。
<h4><a id="%E4%B8%AD%E9%97%B4%E5%B1%82%E7%AE%A1%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>中间层管理</h4>
<p>针对复杂的需求和越来越多的扩展业务，直接调用SDK针对业务开发来说是有接入成本和维护成本的，这里添加业务管理器就很有必要了，开发侧只需要对模板管理器即可，减低维护成本和接入成本。也更好的应对SDK的版本变化。<br />
具体的核心函数功能需要涵盖保底方案、远程方案、预加载等等，每个平台的情况不同，这里不再详细展开。</p>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<ul>
<li>
<p>load方法适配SDK，如果需要立即获取到创建的模板视图，建议主线程调用。</p>
</li>
<li>
<p>由于模板接收对象的核心是字典，有时候由于不同平台排版、渲染可能有差异，为了百分百还原度，且不会交叉影响，可单边添加标识，可同时兼容Android和iOS（操作在NA层）。</p>
</li>
<li>
<p>创建模板视图耗时的问题，可以进行预加载；列表动态高度汇总时，可预暂存，专用承载计算高度，节省耗时。</p>
</li>
<li>
<p>模板刷新是全数据更新布局，针对视图频繁刷新需求的，需要NA化，或者根据业务复杂情况抽离频繁刷新部分即可。</p>
</li>
<li>
<p>针对延展多样的业务，建议创建单独的模板管理器对接组件，业务侧易理解，也更便利的处理适合自己的业务；业务侧只关心模板管理器，不需要关心SDK版本更替。</p>
</li>
</ul>
<h2><a id="%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>避坑指南</h2>
<p>案例1、列表汇总高度计算，如果减少耗时异步调用<code>loadTemplete</code>并不会立即返回所创建的高度，应进行预加载，确保计算时已经获得所创建的动态View。</p>
<p>案例2、动态化view渲染中，多次设置frame；如没有必要的逻辑改变，应抽离出来，否则影响性能。</p>
<p>案例3、xml行间距属性，iOS官方是不支持，目前能看到的文档都没有说明，但源码中应该后来的维护中添加上了，目前是已经支持的，<code>lineSpaceExtra</code>即可胜任。</p>
<pre><code class="language-plain_text">&lt;NText lineSpaceExtra=&quot;1&quot; gravity=&quot;left|top&quot; layoutMarginTop=&quot;16&quot; layoutGravity=&quot;top&quot; layoutWidth=&quot;match_parent&quot; layoutHeight=&quot;wrap_content&quot; text=&quot;${commodityInfo.productName}&quot; lines=&quot;0&quot; maxLines=&quot;2&quot; ellipsize=&quot;end&quot; textSize=&quot;14&quot; textColor=&quot;#222222&quot; textStyle=&quot;bold&quot;/&gt;
</code></pre>
<p>案例4、文本的gravity，双端支持是不一样的，iOS暂只支持水平方向，为了复原完全相同的样式，可以添加platform参数，以一端为基准，微调另一端即可，避免这一端调整好了，另一端排版又乱了。</p>
<p>案例5、NVHLayout类组不支持同向多约束，如遇到此种场景NFrameLayout可胜任。<br />
<figure><img src="media/16346252672275/16381736163004.jpg" alt="图一" /><figcaption>图一<figcaption></figure><br />
<figure><img src="media/16346252672275/16381736990617.jpg" alt="图二" /><figcaption>图二<figcaption></figure><br />
这是NFrameLayout正确的样式展示，图一所示，如右内容大于左部分高度，以右部分为基准，图二所示，如右内容小于左部分高度，以左部分为基准。<br />
如果NVHLayout（内容数据同图一），则是最大高度为左部分高度，右边超出部分则就遮挡起来了，看了下源码，应该是先编译了哪个就按照哪个为基准了，试了下xml样式文件中先布局右侧内容，后布局图片（内容数据同图二），则是左边图片被遮挡住一部分，故经过分析源码和实线，NFrameLayout是可以胜任的。</p>
<p>案例6、模块cell中再去进行<code>loadTemplete</code>耗时不理想；渲染cell时，我们需要的工作是把创建好的动态view进行添加到父视图上，然后进行<code>updateData</code>，然后渲染即可。但<code>loadTemplete</code>内含任务比较多，对于我们此时来说比较冗余，我么应该提前进行预加载，这里直接获取已经创建好的动态view即可。</p>
<h2><a id="%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参考文献</h2>
<p><a href="http://tangram.pingguohe.net/docs/virtualview/elements">动态化方案官网文档</a><br />
<a href="http://weapons.ke.com/project/8371/wiki/page/27157">贝壳业务自定义组件</a><br />
<a href="https://wiki.lianjia.com/pages/viewpage.action?pageId=613625636">贝壳APP动态化建设技术选型</a></p>

    </div>
    <footer class="post-footer clearfix">
      
           
      
        
    </footer>
     <div class="comments-wrap">
        <div class="share-comments">
          

          

          
        </div>
      </div><!-- end comments wrap -->
  </article>
 </div><!-- end-->



    <footer class="footer">
            <div class="container">
                <div class="site-footer-wrapper">
                        <a class="button-square" href="index.html">
<svg class="svg-inline--fa fa-home fa-w-18" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="home" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512" data-fa-i2svg=""><path fill="currentColor" d="M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z"></path></svg>
                            </a>
                        
                         
                        
                        
                        
                        
                      
                      <a class="button-square" href="atom.xml" target="_blank" title="RSS">
                              <svg class="svg-inline--fa fa-rss fa-w-14" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                      </a>

              
                       
                                                
                </div>
                <div class="site-menu-wrapper">
                  &nbsp;<span>|</span>&nbsp;
                  
                    <a target="self" class="" href="index.html">Home</a>
                    &nbsp;<span>|</span>&nbsp;
                  
                    <a target="_self" class="" href="archives.html">Archives</a>
                    &nbsp;<span>|</span>&nbsp;
                                             
                </div>

                <p class="footer-copyright">
                        Copyright &copy; 2019
                        Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
                        Theme used <a target="_blank" href="https://blog.timac.org">Timac</a>.
                </p>
            </div>
        </footer>



  













<script src="asset/prism.js"></script>

        
      
  
    


    </body>
</html>
